# -*- coding: utf-8 -*-
"""Routes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14gi37Wl921rUKIDTFKDFh46PfCB-y8_R
"""

import requests
import json

# Routes data (you need to fill in the coordinates)
routes = [
    {"start": {"lat": 33.7629, "lng": -84.4227}, "end": {"lat": 32.018, "lng": -81.1965}},
    {"start": {"lat": 32.018, "lng": -81.1965}, "end": {"lat": 33.3655, "lng": -82.0734}},
    {"start": {"lat": 33.3655, "lng": -82.0734}, "end": {"lat": 33.9496, "lng": -83.3701}},
    {"start": {"lat": 33.9496, "lng": -83.3701}, "end": {"lat": 32.8088, "lng": -83.6942}},
    {"start": {"lat": 32.8088, "lng": -83.6942}, "end": {"lat": 33.7629, "lng": -84.4227}},
]

# Google API Key
api_key = *HIDDEN*

# Google Maps API endpoint
url = 'https://routes.googleapis.com/directions/v2:computeRoutes'

# List to store route objects
route_objects = []

# Iterate over routes and make requests
for route in routes:
    start_lat = route["start"]["lat"]
    start_lng = route["start"]["lng"]
    end_lat = route["end"]["lat"]
    end_lng = route["end"]["lng"]

    # Request payload
    payload = {
        "origin": {"location": {"latLng": {"latitude": start_lat, "longitude": start_lng}}},
        "destination": {"location": {"latLng": {"latitude": end_lat, "longitude": end_lng}}},
        "travelMode": "DRIVE",
        "routingPreference": "TRAFFIC_AWARE",
        "departureTime": "2024-05-17T19:00:00Z",
        "computeAlternativeRoutes": True,
        "routeModifiers": {
            "avoidTolls": False,
            "avoidHighways": False,
            "avoidFerries": False
        },
        "languageCode": "en-US",
        "units": "IMPERIAL"
    }

    # API request headers
    headers = {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': api_key,
        'X-Goog-FieldMask': 'routes.legs.steps.distanceMeters,routes.routeLabels,routes.legs.steps.startLocation.latLng,routes.legs.steps.endLocation.latLng,routes.polyline.encodedPolyline'
    }

    # Make the request
    try:
        response = requests.post(url, headers=headers, json=payload)
        response.raise_for_status()  # Raise an exception for HTTP errors
        route_object = response.json()
        route_objects.append(route_object)
    except requests.exceptions.HTTPError as e:
        print(f"HTTP error occurred: {e}")
    except json.JSONDecodeError as e:
        print(f"JSON decoding error occurred: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

# Print or further process the route_objects list
print(route_objects[0])

import pandas as pd

chunk_size = 100000

filtered_chunks = []

for chunk in pd.read_csv("US_Accidents_March23.csv", chunksize=chunk_size):
    filtered_chunk = chunk[chunk['State'] == 'GA']
    filtered_chunks.append(filtered_chunk)


df_ga = pd.concat(filtered_chunks, ignore_index=True)

y = df_ga['Severity']
X = df_ga.iloc[:, 11:]
X.drop(columns=['State', 'Country', 'Timezone', 'Airport_Code'], inplace = True)
X['Severity'] = y

X['Weather_Timestamp'] = pd.to_datetime(X['Weather_Timestamp'])
X['day_of_week'] = X['Weather_Timestamp'].dt.day_name()

def is_weekday(day):
    weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
    return day in weekdays

# Apply the function to the day_of_week column to create the Weekday column
X['Weekday'] = X['day_of_week'].apply(lambda x: is_weekday(x))

X.drop(columns=['Weather_Timestamp', 'day_of_week'], inplace = True)

# Calculate the average severity for accidents in each city
df = X.groupby('City')['Severity'].mean()
df = df.reset_index()

print(df)

pip install geopy

from geopy.geocoders import Nominatim

from geopy.exc import GeocoderTimedOut

def get_lat_lon(city, retries=3):
    geolocator = Nominatim(user_agent="my_application")
    for _ in range(retries):
        try:
            location = geolocator.geocode(city, timeout=10)
            if location:
                return location.latitude, location.longitude
        except GeocoderTimedOut:
            continue
    return None, None

# Assuming your DataFrame is named df
df['Latitude'] = 0.0  # Initialize latitude column
df['Longitude'] = 0.0  # Initialize longitude column

for index, row in df.iterrows():
    city = row['City']  # Assuming the city name is the index
    latitude, longitude = get_lat_lon(city)
    df.at[index, 'Latitude'] = latitude
    df.at[index, 'Longitude'] = longitude

# Print the DataFrame to check the result
print(df)

print(df.loc[[df['Severity'].idxmax()]])

print(df.loc[[df['Severity'].idxmin()]])



import math

# Assuming df is the DataFrame containing city locations and severities
city_data = df.set_index('City').to_dict(orient='index')

# New list to store the results
result_dicts = []

# Iterate through route_objects
for route_obj in route_objects:
    # New dictionary to store the results
    result_dict = {}
    for route in route_obj['routes']:

        cumulative_danger = 0

        # Iterate through the legs in each route
        for leg in route['legs']:

            # Iterate through the steps in each leg
            for step in leg['steps']:
                start_lat = step['startLocation']['latLng']['latitude']
                start_lon = step['startLocation']['latLng']['longitude']
                end_lat = step['endLocation']['latLng']['latitude']
                end_lon = step['endLocation']['latLng']['longitude']

                # Calculate average location for the step
                avg_lat = (start_lat + end_lat) / 2
                avg_lon = (start_lon + end_lon) / 2

                # Find the corresponding city
                min_distance = float('inf')
                corresponding_city = None
                for city, city_info in city_data.items():
                    city_lat = city_info['Latitude']
                    city_lon = city_info['Longitude']
                    distance = math.acos(math.sin(math.radians(avg_lat)) * math.sin(math.radians(city_lat)) + math.cos(math.radians(avg_lat)) * math.cos(math.radians(city_lat)) * math.cos(math.radians(city_lon - avg_lon)))

                    if distance < min_distance:
                        min_distance = distance
                        corresponding_city = city

                # Pull the severity level
                severity_level = df.loc[df['City'] == corresponding_city, 'Severity'].values[0]

                # Multiply severity level by distance
                danger = severity_level * step['distanceMeters']

                print(severity_level, corresponding_city, danger)

                # Add to cumulative danger for the route
                cumulative_danger += danger

        result_dict[route['polyline']['encodedPolyline']]=cumulative_danger

    result_dicts.append(result_dict)

print(result_dicts)

print(result_dicts[0].values())

print(result_dicts[0].keys())

# Coding Steps Remaining:

# Iterate through the steps in each route and calculate the average location for each step
# Compare to the latitude longitude locations for cities using an appropriate distance calculation to find the corresponding city
# Pull the corresponding severity level
# Multiply the severity level by the distance associated with the step
# Add all the products for each step
# Track the sums for each route
# Rank order them

# Notes:

# I can do all this pretty easily after the meeting if its helpful,
# the reason I wanted to check is because even if I do all that,
# there is the more serious challenge of using the created polylines and rankings to actually contribute something to the visualization,
# and if we don't think that's feasible we don't need to pursue it at all.

# Possibilities
# Python visualization, interactive with user
# Tableau like shown
# Focus on existing visualizations
# Checkpoint at 7PM

# Useful Packages
# https://gis.stackexchange.com/questions/421259/decoding-polyline-in-python
# https://python-visualization.github.io/folium/latest/user_guide/vector_layers/polyline.html

import polyline
my_string = list(result_dicts[0].keys())[0]
l = polyline.decode(my_string)
print(l[:5])
print(len(l))

import folium

# Separate latitude and longitude values into two lists
latitudes, longitudes = zip(*l)

# Calculate the mean of latitudes and longitudes
mean_latitude = sum(latitudes) / len(latitudes)
mean_longitude = sum(longitudes) / len(longitudes)

# Create the map and add the line
m = folium.Map(location=[mean_latitude, mean_longitude], zoom_start=8)

folium.PolyLine(
    locations=l,
    color="#FF0000",
    weight=5,
    tooltip="From Boston to San Francisco",
).add_to(m)

m

latitudes = []
longitudes = []

# Choose element from list of options to plot
i = 0

for key in result_dicts[i].keys():
    l = polyline.decode(key)
    latitudes_temp, longitudes_temp = zip(*l)
    latitudes.extend(latitudes_temp)
    longitudes.extend(longitudes_temp)

# Calculate the mean of latitudes and longitudes
mean_latitude = sum(latitudes) / len(latitudes)
mean_longitude = sum(longitudes) / len(longitudes)

# Find the key associated with the highest value
best_key = min(result_dicts[i], key=result_dicts[i].get)

# Create the map and add the line
m = folium.Map(location=[mean_latitude, mean_longitude], zoom_start=8)

# Plot the polylines (excluding the best route)
for key in result_dicts[i].keys():
    if key != best_key:
        l = polyline.decode(key)
        color = "#FF0000"
        tooltip = "Alternative Route"
        folium.PolyLine(locations=l, color=color, weight=5, tooltip=tooltip).add_to(m)

# Plot the best route last
l = polyline.decode(best_key)
color = "#0000FF"
tooltip = "Best Route"
folium.PolyLine(locations=l, color=color, weight=5, tooltip=tooltip).add_to(m)

# Create legend
legend_html = '''
     <div style="position: fixed;
                 bottom: 50px; left: 50px; width: 180px; height: 90px;
                 border:2px solid grey; z-index:9999; font-size:14px;
                 background-color:white;
                 ">&nbsp; <b>Legend</b> <br>
                   &nbsp; Best Route &nbsp; <i class="fa fa-map-marker fa-2x" style="color:blue"></i><br>
                   &nbsp; Alternative Route &nbsp; <i class="fa fa-map-marker fa-2x" style="color:red"></i>
     </div>
     '''

m.get_root().html.add_child(folium.Element(legend_html))

m